{"name":"NetRNG","tagline":"Networked entropy distribution system for Raspberry Pi and Beaglebone","body":"============================\r\nNetRNG\r\n============================\r\n\r\n[![Build Status](https://travis-ci.org/infincia/NetRNG.svg?branch=master)](https://travis-ci.org/infincia/NetRNG)\r\n\r\n**Note: The master branch of this code is alpha quality but usable**.\r\n\r\nNetRNG is effectively a network connected hardware random number generator. \r\n\r\nIt allows devices like the RaspberryPi, Beaglebone, or any machine with a TPM, \r\nEntropy Key, or other hardware random number generator onboard to act as a NetRNG \r\nserver, providing high quality random data to other machines on the network. \r\n\r\nVirtual machines can potentially benefit the most from NetRNG, as they typically \r\nsuffer from poor quality local entropy sources due to their running environment.\r\n\r\nNo application or kernel changes are required on NetRNG Client machines; any\r\napplication using ``/dev/random`` and ``/dev/urandom`` will automatically and \r\ntransparently receive entropy from the NetRNG server.\r\n\r\nWhy it exists\r\n-------------\r\n\r\nEntropyBroker is the closest similar project I know of, but it didn't build when I\r\ntried to use it, and the code seems quite large and complicated for a task that,\r\nconceptually, is very simple.\r\n\r\nSo I wrote NetRNG. It's simple code, easy to maintain, easy to deploy, and with \r\nthe exception of some network protocol issues before v0.1, it works quite \r\nwell.\r\n\r\nHow it works\r\n------------\r\n\r\nAs a complete system, NetRNG links ``/dev/hwrng`` on one machine, to ``/dev/random``\r\non many others, carefully ensuring that each machine receives unique entropy samples,\r\nwhile allowing the entropy to be validated for quality and ensuring that entropy\r\nis fairly distributed among connected clients.\r\n\r\nIt is essentially a persistent pipeline from one machine to many others, with\r\nsome minor restrictions on how the pipeline functions to make it suitable for the \r\ntask.\r\n\r\nHowever, netrng.py itself does one job and only one job: it moves random data \r\naround on the local network. Other tasks like validating the samples and providing\r\nthem to the kernel entropy pool are left to ``rngd`` from rng-tools, which is\r\nautomatically started and managed by NetRNG.\r\n\r\n\r\nServer\r\n------\r\n\r\nThe NetRNG server reads from ``/dev/hwrng`` (configurable), dividing up the stream \r\nin to non-repeating, non-overlapping samples of a size defined in the configuration\r\nfile, then sends each one to clients on the local network.\r\n\r\nThe maximum number of clients that will be accepted can be configured on the server,\r\nthis allows you to prevent a slow HWRNG from being spread too thin among too many\r\nclients. \r\n\r\nI'm working on a QoS style load management system that will allow you to guarantee\r\nthat each connected client can receive entropy samples at a specific rate, 10KB/s\r\nfor example. Clients would be allowed to connect until the server could no longer\r\nguarantee that entropy rate to each of them.\r\n\r\n\r\nClient\r\n------\r\n\r\nThe client starts ``rngd`` from rng-tools as a subprocess, then connects to the \r\nserver and starts requesting entropy samples from it. Then each sample is forwarded\r\nto ``rngd`` for processing.\r\n\r\nThen, ``rngd`` validates the quality of the entropy sample before submitting it to \r\nthe Linux or FreeBSD kernel for other programs to use via ``/dev/random``.\r\n\r\n\r\nCommon devices to use as the NetRNG server\r\n------------------------------------------\r\n\r\n* RaspberryPi\r\n* Beaglebone\r\n* PC Engines ALIX\r\n* Various server mainboards\r\n* Any machine with a TPM chip onboard\r\n* Any machine with an Entropy Key\r\n\r\n\r\nSetup\r\n-----\r\n\r\nThere is very little actual configuration required for NetRNG, but until it is\r\npackaged and uploaded to PyPi you'll need to manually clone the repository and\r\npackage it for installation.\r\n\r\nFeel free to install the generated package wherever you like, but ``/opt/NetRNG``\r\nis the default where the bundled init/upstart script are pointed, so if you\r\ninstall the module somewhere else make sure to change them once they're copied\r\nto /etc/.\r\n\r\nI don't advise installing the package in the main system python package directory,\r\nuse a virtualenv to make things easier :)\r\n\r\nNote: these instructions are written for Debian/Ubuntu and derivatives, you'll\r\nneed to determine the equivalent native package names for build-essential and\r\npython-dev.\r\n\r\nThe virtualenv activation is repeated on purpose in certain steps to ensure that\r\nsomeone who isn't following the steps sequentially won't accidentally install\r\npython modules in the global system (not being root helps here, but just in\r\ncase...).\r\n\r\nClone the repo\r\n--------------\r\n\r\n    cd ~/\r\n    git clone https://github.com/infincia/NetRNG.git\r\n\r\nCreate virtualenv\r\n-----------------\r\n\r\nCreate a virtualenv for NetRNG:\r\n\r\n    virtualenv /opt/NetRNG\r\n\r\nSetup build environment\r\n-----------------------\r\n\r\nSome NetRNG dependencies require building python C extensions, so we need to\r\ninstall a compiler and python development headers so they'll build properly\r\nduring installation of the NetRNG package:\r\n\r\n    apt-get install build-essential\r\n    apt-get install python-dev\r\n\r\nThe `wheel` module is also needed to build NetRNG, so we install it in to the\r\nvirtualenv:\r\n\r\n    source /opt/NetRNG/bin/activate\r\n    pip install wheel\r\n\r\nBuild and install NetRNG\r\n-----------------------------\r\n\r\n    cd ~/NetRNG\r\n    source /opt/NetRNG/bin/activate\r\n    python setup.py bdist_wheel\r\n    pip install dist/netrng*.whl\r\n\r\n\r\nInstall rng-tools\r\n-----------------\r\n\r\nOn some Linux distributions, rng-tools is installed by default. For others you\r\nwill need to install it yourself.\r\n\r\nOn Ubuntu or Debian you can install it like this:\r\n\r\n    sudo apt-get install rng-tools\r\n    \r\nI have not tested NetRNG on FreeBSD, but rng-tools seems to support FreeBSD so\r\nit should work. You'll need to install rng-tools from the ports collection.\r\n    \r\nConfiguration\r\n-------------\r\n\r\nCopy and rename the sample config file on all machines before use:\r\n\r\n    cp /opt/NetRNG/conf/netrng.conf.sample /etc/netrng.conf\r\n\r\nThe NetRNG server requires very little configuration on most systems, but the \r\nclient requires setting the right server address and setting the mode to 'client'. \r\n\r\nThe rest of the configuration should be fine unless you have a very slow HWRNG and \r\nneed to tweak the data flow settings. The defaults send 2KB chunks of random data \r\nto each connected client as fast as possible. You can tweak sample_size_bytes if \r\nneeded. This process may be automated in the future.\r\n\r\n\r\nRun for testing\r\n---------------\r\n\r\nSince the compiled daemon script is available on your path while the virtualenv\r\nis activated, you can run it directly after the config file is determined to be\r\ncorrect:\r\n\r\n    source /opt/NetRNG/bin/activate\r\n    netrngd\r\n\r\n\r\nLong term use\r\n-------------\r\n\r\nI have written both Upstart and systemd scripts for netrngd.\r\n\r\nIf someone would like to contribute other types of init scripts I will gladly \r\naccept a pull request.\r\n\r\nTo use the the systemd script:\r\n\r\n    cp /opt/NetRNG/conf/netrng.service /etc/systemd/system/\r\n    systemctl daemon-reload\r\n    systemctl start netrng\r\n    \r\nTo use the Upstart script:\r\n\r\n    cp /opt/NetRNG/conf/netrng.conf.upstart /etc/init/netrng.conf\r\n    service netrng start\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}